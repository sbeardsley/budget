{
    // Place your budget workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    // "Print to console": {
    // 	"scope": "javascript,typescript",
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "sqlite connection pool": {
        "scope": "rust",
        "prefix": "sqlite",
        "body": [
            "use core::domain::errors::ConnectionError;",
            "use sqlx::{migrate::MigrateDatabase, pool::PoolConnection, Pool, Sqlite, SqlitePool};",
            "",
            "#[derive(Debug, Clone)]",
            "pub struct SqliteConnectionPool {",
            "    pool: Pool<Sqlite>,",
            "}",
            "",
            "impl SqliteConnectionPool {",
            "    pub async fn new(db_url: &str) -> Result<Self, ConnectionError> {",
            "        Self::ensure_db_exists(db_url).await?;",
            "        Self::run_migrations(db_url).await?;",
            "",
            "        let pool = SqlitePool::connect(db_url)",
            "            .await",
            "            .map_err(|_| ConnectionError::ConnectionFailed)?;",
            "",
            "        Ok(Self { pool })",
            "    }",
            "",
            "    pub async fn close(&self) {",
            "        self.pool.close().await",
            "    }",
            "",
            "    pub async fn connect(&self) -> Result<PoolConnection<Sqlite>, ConnectionError> {",
            "        let mut conn = self",
            "           .pool",
            "           .clone()",
            "           .acquire()",
            "           .await",
            "           .map_err(|_| ConnectionError::ConnectionFailed)?;",
            "",
            "        sqlx::query!(r#\"PRAGMA foreign_keys = ON;\"#)",
            "           .execute(&mut *conn)",
            "           .await",
            "           .map_err(|_| ConnectionError::ConnectionFailed)?;",
            "",
            "        Ok(conn)",
            "    }",
            "",
            "    pub async fn ensure_db_exists(url: &str) -> Result<(), ConnectionError> {",
            "        if !Sqlite::database_exists(url).await.unwrap_or(false) {",
            "            println!(\"Creating database {}\", url);",
            "            match Sqlite::create_database(url).await {",
            "                Ok(_) => println!(\"Create db success\"),",
            "                Err(error) => panic!(\"error: {}\", error),",
            "            };",
            "        };",
            "",
            "        Ok(())",
            "    }",
            "",
            "    pub async fn run_migrations(url: &str) -> Result<(), ConnectionError> {",
            "        let db = SqlitePool::connect(url)",
            "            .await",
            "            .map_err(|_| ConnectionError::ConnectionFailed)?;",
            "",
            "        let migrations = std::env::current_dir()",
            "            .map_err(|_| ConnectionError::MigrationFailed)?",
            "            .join(\"./migrations\");",
            "",
            "        sqlx::migrate::Migrator::new(migrations)",
            "            .await",
            "            .map_err(|_| ConnectionError::MigrationFailed)?",
            "            .run(&db)",
            "            .await",
            "            .map_err(|_| ConnectionError::MigrationFailed)?;",
            "",
            "        Ok(())",
            "    }",
            "}"
        ]
    },
    "sqlite repository create": {
        "scope": "rust",
        "prefix": "repo_create_sqlite",
        "body": [
            "use chrono::{TimeZone, Utc};",
            "use sqlx::types::Uuid;",
            "",
            "use core::{",
            "    domain::{",
            "        errors::Create${1/(.*)/${1:/pascalcase}/}Error,",
            "        models::{${1/(.*)/${1:/pascalcase}/}Draft, New${1/(.*)/${1:/pascalcase}/}},",
            "    },",
            "    repositories::Create${1/(.*)/${1:/pascalcase}/}RepositoryContract,",
            "};",
            "use std::{str::FromStr, sync::Arc};",
            "",
            "use super::sqlite_connection_pool::SqliteConnectionPool;",
            "",
            "#[derive(Debug, Clone)]",
            "pub struct Create${1/(.*)/${1:/pascalcase}/}Repository {",
            "    db: Arc<SqliteConnectionPool>,",
            "}",
            "",
            "impl Create${1/(.*)/${1:/pascalcase}/}Repository {",
            "    pub fn new(db: Arc<SqliteConnectionPool>) -> Self {",
            "        Self { db }",
            "    }",
            "}",
            "",
            "impl Create${1/(.*)/${1:/pascalcase}/}RepositoryContract for Create${1/(.*)/${1:/pascalcase}/}Repository {",
            "    async fn insert_${1/(.*)/${1:/downcase}/}(&self, ${1/(.*)/${1:/downcase}/}: ${1/(.*)/${1:/pascalcase}/}Draft) -> Result<New${1/(.*)/${1:/pascalcase}/}, Create${1/(.*)/${1:/pascalcase}/}Error> {",
            "        let mut connection = self",
            "            .db",
            "            .clone()",
            "            .connect()",
            "            .await",
            "            .map_err(|_| Create${1/(.*)/${1:/pascalcase}/}Error::Unknown)?;",
            "",
            "        let id = Uuid::now_v7().to_string();",
            "        let now = Utc::now();",
            "        let name = ${1/(.*)/${1:/downcase}/}.name;",
            "        let created_at = now;",
            "        let updated_at = now;",
            "",
            "        match sqlx::query!(",
            "            r#\"",
            "            INSERT INTO ${1/(.*)/${1:/downcase}/}s (id, name, created_at, updated_at)",
            "            VALUES (\\$1, \\$2, \\$3, \\$4)",
            "            RETURNING id, name, created_at, updated_at;",
            "            \"#,",
            "            id,",
            "            name,",
            "            created_at,",
            "            updated_at,",
            "        )",
            "        .map(|row| {",
            "            Ok(New${1/(.*)/${1:/pascalcase}/} {",
            "                    id: Uuid::from_str(&row.id).map_err(|_| Create${1/(.*)/${1:/pascalcase}/}Error::Unknown)?,",
            "                    name: row.name,",
            "                    created_at: Utc.from_utc_datetime(&row.created_at),",
            "                    updated_at: Utc.from_utc_datetime(&row.updated_at),",
            "                })",
            "        })",
            "        .fetch_one(&mut *connection)",
            "        .await",
            "        {",
            "            Ok(${1/(.*)/${1:/downcase}/}) => ${1/(.*)/${1:/downcase}/},",
            "            Err(e) => {",
            "                println!(\"Error inserting ${1/(.*)/${1:/downcase}/} {}\", e);",
            "                Err(Create${1/(.*)/${1:/pascalcase}/}Error::Unknown)",
            "            }",
            "        }",
            "    }",
            "}"
        ]
    },
    "sqlite repository update": {
        "scope": "rust",
        "prefix": "repo_update_sqlite",
        "body": [
            "use chrono::{TimeZone, Utc};",
            "use sqlx::types::Uuid;",
            "",
            "use core::{",
            "    domain::{",
            "        errors::Update${1/(.*)/${1:/pascalcase}/}Error,",
            "        models::{${1/(.*)/${1:/pascalcase}/}Patch, New${1/(.*)/${1:/pascalcase}/}},",
            "    },",
            "    repositories::Update${1/(.*)/${1:/pascalcase}/}RepositoryContract,",
            "};",
            "use std::{str::FromStr, sync::Arc};",
            "",
            "use super::sqlite_connection_pool::SqliteConnectionPool;",
            "",
            "#[derive(Debug, Clone)]",
            "pub struct Update${1/(.*)/${1:/pascalcase}/}Repository {",
            "    db: Arc<SqliteConnectionPool>,",
            "}",
            "",
            "impl Update${1/(.*)/${1:/pascalcase}/}Repository {",
            "    pub fn new(db: Arc<SqliteConnectionPool>) -> Self {",
            "        Self { db }",
            "    }",
            "}",
            "",
            "impl Update${1/(.*)/${1:/pascalcase}/}RepositoryContract for Update${1/(.*)/${1:/pascalcase}/}Repository {",
            "    async fn update_${1/(.*)/${1:/downcase}/}(&self, ${1/(.*)/${1:/downcase}/}_id: Uuid, ${1/(.*)/${1:/downcase}/}: ${1/(.*)/${1:/pascalcase}/}Patch) -> Result<New${1/(.*)/${1:/pascalcase}/}, Update${1/(.*)/${1:/pascalcase}/}Error> {",
            "        let mut connection = self",
            "            .db",
            "            .clone()",
            "            .connect()",
            "            .await",
            "            .map_err(|_| Update${1/(.*)/${1:/pascalcase}/}Error::Unknown)?;",
            "",
            "        let id = Uuid::now_v7().to_string();",
            "        let now = Utc::now();",
            "        let name = ${1/(.*)/${1:/downcase}/}.name;",
            "        let created_at = now;",
            "        let updated_at = now;",
            "",
            "        match sqlx::query!(",
            "            r#\"",
            "            UPDATE ${1/(.*)/${1:/downcase}/}s",
            "            SET name = \\$2",
            "            WHERE id = \\$1",
            "            RETURNING id, name, created_at, updated_at;",
            "            \"#,",
            "            id,",
            "            name,",
            "        )",
            "        .map(|row| {",
            "            Ok(New${1/(.*)/${1:/pascalcase}/} {",
            "                    id: Uuid::from_str(&row.id).map_err(|_| Update${1/(.*)/${1:/pascalcase}/}Error::Unknown)?,",
            "                    name: row.name,",
            "                    created_at: Utc.from_utc_datetime(&row.created_at),",
            "                    updated_at: Utc.from_utc_datetime(&row.updated_at),",
            "                })",
            "        })",
            "        .fetch_one(&mut *connection)",
            "        .await",
            "        {",
            "            Ok(${1/(.*)/${1:/downcase}/}) => ${1/(.*)/${1:/downcase}/},",
            "            Err(e) => {",
            "                println!(\"Error inserting ${1/(.*)/${1:/downcase}/} {}\", e);",
            "                Err(Update${1/(.*)/${1:/pascalcase}/}Error::Unknown)",
            "            }",
            "        }",
            "    }",
            "}"
        ]
    },
    "sqlite repository get one": {
        "scope": "rust",
        "prefix": "repo_get_one_sqlite",
        "body": [
            "use chrono::{TimeZone, Utc};",
            "use sqlx::types::Uuid;",
            "",
            "use core::{",
            "    domain::{",
            "        errors::GetOne${1/(.*)/${1:/pascalcase}/}Error,",
            "        models::New${1/(.*)/${1:/pascalcase}/},",
            "    },",
            "    repositories::GetOne${1/(.*)/${1:/pascalcase}/}RepositoryContract,",
            "};",
            "use std::{str::FromStr, sync::Arc};",
            "",
            "use super::sqlite_connection_pool::SqliteConnectionPool;",
            "",
            "#[derive(Debug, Clone)]",
            "pub struct GetOne${1/(.*)/${1:/pascalcase}/}Repository {",
            "    db: Arc<SqliteConnectionPool>,",
            "}",
            "",
            "impl GetOne${1/(.*)/${1:/pascalcase}/}Repository {",
            "    pub fn new(db: Arc<SqliteConnectionPool>) -> Self {",
            "        Self { db }",
            "    }",
            "}",
            "",
            "impl GetOne${1/(.*)/${1:/pascalcase}/}RepositoryContract for GetOne${1/(.*)/${1:/pascalcase}/}Repository {",
            "    async fn get_one_${1/(.*)/${1:/downcase}/}(&self, ${1/(.*)/${1:/downcase}/}_id: Uuid) -> Result<Option<New${1/(.*)/${1:/pascalcase}/}>, GetOne${1/(.*)/${1:/pascalcase}/}Error> {",
            "        let mut connection = self",
            "            .db",
            "            .clone()",
            "            .connect()",
            "            .await",
            "            .map_err(|_| GetOne${1/(.*)/${1:/pascalcase}/}Error::Unknown)?;",
            "",
            "        match sqlx::query!(",
            "            r#\"",
            "            SELECT id, name, created_at, updated_at",
            "            FROM ${1/(.*)/${1:/downcase}/}s",
            "            WHERE id = \\$1",
            "            \"#,",
            "            ${1/(.*)/${1:/downcase}/}_id,",
            "        )",
            "        .map(|row| -> Option<New${1/(.*)/${1:/pascalcase}/}> {",
            "            let id = Uuid::from_str(&row.id).ok();",
            "            let user_id = Uuid::from_str(&row.user_id).ok();",
            "",
            "            if Some(id) == None || Some(user_id) == None {",
            "               return None",
            "            }",
            "",
            "            Some(New${1/(.*)/${1:/pascalcase}/} {",
            "                    id: Uuid::from_str(&row.id).expect(\"unable to parse id\"),",
            "                    name: row.name,",
            "                    user_id: Uuid::from_str(&row.user_id).expect(\"unable to parse user_id\")",
            "                    created_at: Utc.from_utc_datetime(&row.created_at),",
            "                    updated_at: Utc.from_utc_datetime(&row.updated_at),",
            "                })",
            "        })",
            "        .fetch_one(&mut *connection)",
            "        .await",
            "        {",
            "            Ok(${1/(.*)/${1:/downcase}/}) => Ok(${1/(.*)/${1:/downcase}/}),",
            "            Err(_) => Err(GetOne${1/(.*)/${1:/pascalcase}/}Error::Unknown)",
            "        }",
            "    }",
            "}"
        ]
    },
    "sqlite repository get all": {
        "scope": "rust",
        "prefix": "repo_get_all_sqlite",
        "body": [
            "use chrono::{TimeZone, Utc};",
            "use sqlx::types::Uuid;",
            "",
            "use core::{",
            "    domain::{",
            "        errors::GetAll${1/(.*)/${1:/pascalcase}/}sError,",
            "        models::New${1/(.*)/${1:/pascalcase}/},",
            "    },",
            "    repositories::GetAll${1/(.*)/${1:/pascalcase}/}sRepositoryContract,",
            "};",
            "use std::{str::FromStr, sync::Arc};",
            "",
            "use super::sqlite_connection_pool::SqliteConnectionPool;",
            "",
            "#[derive(Debug, Clone)]",
            "pub struct GetAll${1/(.*)/${1:/pascalcase}/}sRepository {",
            "    db: Arc<SqliteConnectionPool>,",
            "}",
            "",
            "impl GetAll${1/(.*)/${1:/pascalcase}/}sRepository {",
            "    pub fn new(db: Arc<SqliteConnectionPool>) -> Self {",
            "        Self { db }",
            "    }",
            "}",
            "",
            "impl GetAll${1/(.*)/${1:/pascalcase}/}sRepositoryContract for GetAll${1/(.*)/${1:/pascalcase}/}sRepository {",
            "    async fn get_all_${1/(.*)/${1:/downcase}/}s(&self, user_id: Uuid) -> Result<Vec<New${1/(.*)/${1:/pascalcase}/}>, GetAll${1/(.*)/${1:/pascalcase}/}sError> {",
            "        let mut connection = self",
            "            .db",
            "            .clone()",
            "            .connect()",
            "            .await",
            "            .map_err(|_| GetAll${1/(.*)/${1:/pascalcase}/}sError::Unknown)?;",
            "",
            "        match sqlx::query!(",
            "            r#\"",
            "            SELECT id, name, created_at, updated_at",
            "            FROM ${1/(.*)/${1:/downcase}/}s",
            "            WHERE id = \\$1",
            "            \"#,",
            "            user_id,",
            "        )",
            "        .map(|row| -> Option<New${1/(.*)/${1:/pascalcase}/}> {",
            "            let id = Uuid::from_str(&row.id).ok();",
            "            let user_id = Uuid::from_str(&row.user_id).ok();",
            "",
            "            if Some(id) == None || Some(user_id) == None {",
            "               return None",
            "            }",
            "",
            "            Some(New${1/(.*)/${1:/pascalcase}/} {",
            "                    id: Uuid::from_str(&row.id).expect(\"unable to parse id\"),",
            "                    name: row.name,",
            "                    user_id: Uuid::from_str(&row.user_id).expect(\"unable to parse user_id\")",
            "                    created_at: Utc.from_utc_datetime(&row.created_at),",
            "                    updated_at: Utc.from_utc_datetime(&row.updated_at),",
            "                })",
            "        })",
            "        .fetch_all(&mut *connection)",
            "        .await",
            "        {",
            "            Ok(${1/(.*)/${1:/downcase}/}s) => Ok(${1/(.*)/${1:/downcase}/}s.into_iter().flatten().collect()),",
            "            Err(_) => Err(GetAll${1/(.*)/${1:/pascalcase}/}sError::Unknown)",
            "        }",
            "    }",
            "}"
        ]
    }
}
